#!/usr/bin/env python3

# AUTHOR: Nicholas Preston (npgy) and Alexis Masson (Aveheuzed)

import subprocess
import mutagen
import time
import argparse
import shutil
import pathlib
import tempfile
import shlex
from sys import exit
import os, sys

def get_runtime(filename):
    """Returns the runtime of a file

    ;param filename: the file's full path
    ;return: the file's runtime as a float
    """
    raw_info = mutagen.File(filename).info.pprint()
    runtime = float(raw_info.rsplit(', ', 1)[1].split(' ')[0])
    return runtime

def get_timestamp(seconds):
    """Returns the formatted timestamp

    ;param seconds: the length of time in seconds
    ;return: the formatted timestamp
    """
    return time.strftime("%H:%M:%S", time.gmtime(seconds))

def throw_error(text):
    print("ERROR: "+text)
    exit(1)

def cleanup(temp_dir):
    """
    Cleans up temporary files that may have been generated
    """
    # rmdir() method of pathlib.PosixPath instance
    # Remove this directory.  The directory must be empty.
    for file in temp_dir.iterdir() :
        file.unlink()

    temp_dir.rmdir()

def preprocess_files(infiles, tmpd) :
    """Run the sound preprocessing stage.
    Returns: list of files generated by ffmpeg, (absolute paths)
    """

    outfiles = [(tmpd/file.name).with_suffix(".m4a").absolute() for file in infiles]

    # First pass to encode audio (this avoids errors in the final render)
    for inf, outf in zip(infiles, outfiles):
        first_pass_cmd = [FFMPEG,
            "-i", inf,
            "-map", "0",
            "-map", "-v?",
            "-map", "-V?",
            "-acodec", "aac",
            "-b:a", "320k",
            outf,
        ]
        subprocess.call(first_pass_cmd)

    return outfiles

def preprocess_files_fast(infiles, tmpd) :
    """_Do not_ run the sound preprocessing stage.
    Returns: outfile (== infiles)
    """
    outfiles = infiles.copy()
    return outfiles

def gen_filelist(infiles, tmpd) :
        """Write all audio files to a temporary text document for ffmpeg
        Returns the path of that text document."""

        filename = tmpd/"files.txt"
        with open(filename, "w") as f:
            for file in infiles:
                print("file", shlex.quote(str(file)), file=f)

        return filename

def gen_tracklist(infiles, outfile) :
    """Calculate tracklist with timestamps, write the result in `outfile`."""
    with open(outfile, "w") as f:
        curr_time = 0.0
        for file in infiles:
            print(shlex.quote(file.stem), "--", get_timestamp(curr_time), file=f)
            curr_time += get_runtime(file)

def getcover(srcdir) :
    """Find and return cover art in srcdir"""
    COVER_PATTERNS = ("cover.jpg", "cover.png")
    cover = [f for f in srcdir.iterdir() if f.is_file and f.name in COVER_PATTERNS]
    if len(cover) == 1 :
        return cover[0]
    else :
        throw_error("The cover photo could not be found")

def getsrcfiles(srcdir) :
    """Find all audio files in the directory. Returns a list of (absolute) paths."""
    exts = ('.wav', '.mp3', '.m4a', '.ogg', '.flac')
    files = [f.absolute() for f in srcdir.iterdir() if f.is_file and f.suffix in exts]
    if len(files) == 0:
        throw_error("The audio files could not be found")

    # Sort the list of files by name
    files.sort(key=lambda x: x.stem)

    return files

def main_ffmpeg_call(filelist, cover, outfile) :
    """Run the final rendering stage, using
    the filelist from `gen_filelist()` and the cover from `getcover()`."""
    # Construct FFMPEG command for final render
    render_cmd = [FFMPEG,
        "-hwaccel", "auto",
        "-y",
        "-loop", "1",
        "-framerate", "1",
        "-i", cover,
        "-f", "concat",
        "-safe", "0",
        "-i", filelist,
        "-tune", "stillimage",
        "-shortest",
        "-fflags", "+shortest",
        "-max_interleave_delta", "100M",
        "-vf", "format=yuv420p",
        "-s", "1080x1080",
        "-b:a", "320k",
        outfile,
    ]
    subprocess.call(render_cmd)

FFMPEG = None

# Grab the correct binary for FFMPEG for either frozen exe or regular py script
if getattr(sys, 'frozen', False):
    FFMPEG = "ffmpeg"
elif __file__:
    FFMPEG = shutil.which("ffmpeg")

# Check if FFMPEG binary exists
if not FFMPEG:
    throw_error("An FFMPEG installation could not be found on your system. Make sure it's installed and added to your path variable.")

parser = argparse.ArgumentParser(description="A command line tool for generating videos from albums/tracks")
parser.add_argument('-f', '--fast', action='store_true', help="Enables fast mode, may cause rendering errors")
parser.add_argument("path", nargs="?", default="", help="The full path to the album's folder", type=pathlib.Path)
args = parser.parse_args()

# Verify directory is valid
if not (args.path.exists() and args.path.is_dir()):
    throw_error("The directory could not be found")

# Temp directory for first pass transcoding
temp_dir = pathlib.Path(tempfile.mkdtemp())

print("Welcome to album2vid!\n")

source_files = getsrcfiles(args.path)
cover = getcover(args.path)

if args.fast :
    ppfiles = preprocess_files_fast(source_files, temp_dir)
else :
    ppfiles = preprocess_files(source_files, temp_dir)

filelist = gen_filelist(ppfiles, temp_dir)
gen_tracklist(source_files, args.path/"tracklist.txt")

main_ffmpeg_call(filelist, cover, args.path/"out.mp4")

cleanup(temp_dir)

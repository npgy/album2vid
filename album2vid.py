# AUTHOR: Nicholas Preston (npgy) and Alexis Masson (Aveheuzed)

import subprocess
import mutagen
import time
import argparse
import shutil
import pathlib
import tempfile
import shlex

def get_runtime(filename):
    """Returns the runtime of a file

    ;param filename: the file's full path
    ;return: the file's runtime as a float
    """
    raw_info = mutagen.File(filename).info.pprint()
    runtime = float(raw_info.rsplit(', ', 1)[1].split(' ')[0])
    return runtime

def get_timestamp(seconds):
    """Returns the formatted timestamp

    ;param seconds: the length of time in seconds
    ;return: the formatted timestamp
    """
    return time.strftime("%H:%M:%S", time.gmtime(seconds))

def throw_error(text):
    print("ERROR: "+text)
    exit(1)



def cleanup(temp_dir):
    """
    Cleans up temporary files that may have been generated
    """
    # rmdir() method of pathlib.PosixPath instance
    # Remove this directory.  The directory must be empty.
    for file in temp_dir.iterdir() :
        file.unlink()

    temp_dir.rmdir()

def preprocess_files(infiles, tmpd) :
    """Run the sound preprocessing stage.
    Returns: list of files generated by ffmpeg, (absolute paths)
    """

    outfiles = [(tmpd/file.name).with_suffix(".m4a").absolute() for file in infiles]

    # First pass to encode audio (this avoids errors in the final render)
    for inf, outf in zip(infiles, outfiles):
        first_pass_cmd = [FFMPEG,
            "-i", inf,
            "-map", "0",
            "-map", "-v?",
            "-map", "-V?",
            "-acodec", "aac",
            "-b:a", "320k",
            outf,
        ]
        subprocess.call(first_pass_cmd)

    return outfiles

def preprocess_files_fast(infiles, tmpd) :
    """_Do not_ run the sound preprocessing stage.
    Returns: outfile (== infiles)
    """
    outfiles = infiles.copy()
    return outfiles

def gen_filelist(infiles, tmpd) :
        """Write all audio files to a temporary text document for ffmpeg
        Returns the path of that text document."""

        filename = tmpd/"files.txt"
        with open(filename, "w") as f:
            for file in infiles:
                print("file", shlex.quote(str(file)), file=f)

        return filename

def gen_tracklist(infiles, outfile) :
    """Calculate tracklist with timestamps, write the result in `outfile`."""
    with open(outfile, "w") as f:
        curr_time = 0.0
        for file in infiles:
            print(shlex.quote(file.stem), "--", get_timestamp(curr_time), file=f)
            curr_time += get_runtime(file)

def getcover(srcdir) :
    """Find and return cover art in srcdir"""
    COVER_PATTERNS = ("cover.jpg", "cover.png")
    cover = [f for f in srcdir.iterdir() if f.is_file and f.name in COVER_PATTERNS]
    if len(cover) == 1 :
        return cover[0]
    else :
        throw_error("The cover photo could not be found")

def getsrcfiles(srcdir) :
    """Find all audio files in the directory. Returns a list of (absolute) paths."""
    exts = ('.wav', '.mp3', '.m4a', '.ogg', '.flac')
    files = [f.absolute() for f in srcdir.iterdir() if f.is_file and f.suffix in exts]
    if len(files) == 0:
        throw_error("The audio files could not be found")

    # Sort the list of files by name
    files.sort(key=lambda x: x.stem)

    return files

def main_ffmpeg_call(filelist, cover, outfile) :
    """Run the final rendering stage, using
    the filelist from `gen_filelist()` and the cover from `getcover()`."""
    # Construct FFMPEG command for final render
    render_cmd = [FFMPEG,
        "-hwaccel", "auto",
        "-y",
        "-loop", "1",
        "-framerate", "1",
        "-i", cover,
        "-f", "concat",
        "-safe", "0",
        "-i", filelist,
        "-tune", "stillimage",
        "-shortest",
        "-fflags", "+shortest",
        "-max_interleave_delta", "100M",
        "-vf", "format=yuv420p",
        "-s", "1080x1080",
        "-b:a", "320k",
        outfile,
    ]
    subprocess.call(render_cmd)

# FFMPEG binary location
FFMPEG = shutil.which("ffmpeg")

parser = argparse.ArgumentParser(description="A command line tool for generating videos from albums/tracks")
parser.add_argument('-f', '--fast', action='store_true', help="Enables fast mode, may cause rendering errors")
parser.add_argument("path", nargs="?", default="", help="The full path to the album's folder", type=pathlib.Path)
args = parser.parse_args()

# Verify directory is valid
if not (args.path.exists() and args.path.is_dir()):
    throw_error("The directory could not be found")

# Temp directory for first pass transcoding
temp_dir = pathlib.Path(tempfile.mkdtemp())

print("Welcome to album2vid!\n")

source_files = getsrcfiles(args.path)
cover = getcover(args.path)

if args.fast :
    ppfiles = preprocess_files_fast(source_files, temp_dir)
else :
    ppfiles = preprocess_files(source_files, temp_dir)

filelist = gen_filelist(ppfiles, temp_dir)
gen_tracklist(source_files, args.path/"tracklist.txt")

main_ffmpeg_call(filelist, cover, args.path/"out.mp4")

cleanup(temp_dir)
